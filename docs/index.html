<meta charset="utf-8" emacsmode="-*- markdown -*-"><link rel="stylesheet" href="apidoc_modified.css">

**Photoshop C++ Recipes**

Hi.

If you read the title of this document and are wondering if I'm going to be
introducing some delicious recipes for your next weekend brunch, the answer is
no. Instead, I'll be going over some seemingly innocuous tasks that you might
find yourself doing should you ever have the unfortunate task of having to work
on native Photoshop plugins.

Just so you can know at a glance if this tutorial is for you, I'll be covering
the following topics:

* Getting started creating native (C++) Photoshop plugins in a minimalist manner;

* Reading layer data directly within Photoshop entirely through C++;

* Combining an Automation to run a "hidden" Filter plugin;

* Making our own GUI tools in Photoshop without going through CEP,
  using [ImGui](https://github.com/ocornut/imgui);

* Communicating between a traditional CEP panel in Photoshop and a native C++
  plugin using Adobe native CSXS events;

Some of these recipes are already in the samples included in the SDK, but
they're pretty obtuse and not necessarily implemented in an easy-to-understand
manner (at least, it took me a while to grok them). Hopefully the recipes here
will be far less bloated.


# Code Repository #

All the source code for this tutorial is available [here](https://github.com/sonictk/ps_cpp_recipes).


# Motivation #

## Why not CEP instead? ##

If you've had any experience working with Photoshop development before, you'll
likely be familar with the [Adobe CEP framework](https://github.com/Adobe-CEP),
which is basically's Adobe idea of allowing developers to extend Photoshop
through the "modern" set of web technologies, and being able to share those
creations across the entire Adobe suite.

Unfortunately (as with most over-complicated things in programming), while this
sounds very nice in theory, it's an unmitigated disaster in practice. While I'll
explain in detail later on, here's a brief list of bullet points:

* For reasons which will be explained later, CEP is _slow_. It's to the point
  where for certain operations (not even at scale), it's so slow in execution as
  to be unusable.

* Debugging the CEP JavaScript/Adobe JSX layers is incredibly time-consuming and
  sometimes also impossible, depending on the exposed API calls you're
  attempting to make. Also, if there's a bug in the CEP/JS layer itself, you
  likely will have no chance of solving it on your own without Adobe's help (and
  good luck with that!).

* It's JavaScript. Which probably sounded like a good idea to some product
  manager back in the day, but now just serves to be a major pain even when
  programming in it.


# Requirements #

This tutorial will focus on writing only the Windows version of any plugins,
since Photoshop is only supported on Windows/OSX and really, the concepts I'm
going to illustrate are OS-agnostic. However, in the event that I find it useful
to cover information regarding those platforms, it will appear in the following
format:

!!! tip Crossing the platforms
    Platform-specific information goes here.


## What you will need ##

- Windows 10 and Photoshop CC 2019/2020 or later.

- A **C/C++ development environment** set up and ready to go. (If you want to see
  what my Emacs setup looks like, it's
  available [here](https://github.com/sonictk/lightweight-emacs).)

- MSVC 2017 (Photoshop 2019).

!!! warning MSVC Compiler versions
    There's not much official information (if any) that I could find regarding
    the recommended compiler versions that should be used to compile plugins for
    each version of Photoshop. I've tested 2017 against Photoshop 2019 pretty
    thoroughly and haven't found any major issues (I would assume 2019 would be
    OK as well, since they are ABI-compatible).

- The Adobe Photoshop SDK for your particular version of Photoshop.
  They can be downloaded from the following location:
  https://console.adobe.io/downloads (You'll need an Adobe account.)
  Versions prior to CC 2014 may be downloaded from the following
  location: https://www.adobe.com/devnet/photoshop/sdk.html

- The Adobe CEP SDK for your particular version of Photoshop. This can also be
  downloaded from the [same earlier location](https://console.adobe.io/downloads)
  as the Photoshop SDK.


## What you should know ##

- **Competency with C/C++**. This tutorial will not focus on basics, and is
  meant to be more of a quickstart guide for programmers already experienced
  with C++ to dive into the specifics of Photoshop plugin development.

- **Basic knowledge of JavaScript**. We will be writing a little JavaScript code
  here and there (simply to demonstrate usage of CEP, since that is still to
  date the only officially recommended way to create GUIs in Photoshop), so
  you'll need to be able to grok the syntax.

- **Basic knowledge of Photoshop**. Since we're going to be writing plugins for
  it, it would be helpful if you knew what a layer was, for example, or what
  a filter is.

Let's get started with the various recipes. Feel free to skip ahead if you're
not interested in a particular topic.


# Recipe: Minimalist approach to Photoshop plug-ins #

This recipe will teach you how to create a native C++ Photoshop plugin from
scratch and without involving an IDE; this will be as minimalist a
setup as possible.

## Getting the documentation ##

The documentation for the Photoshop SDK is fairly old and hasn't been
updated regularly in a while, but it's still useful in some ways. Your
copy of the documentation (`documentation.html`) is included in the
SDK that you downloaded.

For initial reading, find the page on **Types of plug-in modules** and
go over the different types of Photoshop plug-ins that are supported,
and their corresponding limitations. Basically, Photoshop segregates
the different types of plug-ins that one can write to extend the
functionality of the host program, and each type of plug-in has a
different entry point that Photoshop is expecting to call, along with
a different defined file extension.

For example, **filter** plug-ins (the kind that show up in the
**Filter** menu, which basically run math operations on your layer's
image pixels) have the entry point signature of:

~~~~~~
DLLExport MACPASCAL void PluginMain(const int16_t selector,
                                    FilterRecordPtr filterRecord,
                                    long long *data,
                                    int16_t *result);
~~~~~~

and a file extension of `.8bf`, whereas **automation** plug-ins have
a different entry point that Photoshop calls:

~~~~~~
DLLExport SPAPI SPErr AutoPluginMain(const char* caller,
                                     const char* selector,
                                     void* message);
~~~~~~

and a file extension of `.8li` instead.

If you're attempting to write one of the other types of plugins, I
suggest taking a look at the sample code, also provided with the
documentation.

## Hello, world ##

Let's go ahead and create our first Photoshop plugin. To make things
simple, we'll be making an **Automation** plug-in, which is generally
meant for tools or other, as the name implies, automated processes to
occur on Photoshop documents.

You can refer to the various samples within the SDK to see more about
Automation plugins in general, but for the purposes of this tutorial,
go ahead and create `tutorial_automation_main.cpp`, and fill it with
the following code:


~~~~~~cpp
SPBasicSuite *sSPBasic = NULL;


SPErr UninitializePlugin()
{
    PIUSuitesRelease();
    return status;
}


DLLExport SPAPI SPErr AutoPluginMain(const char* caller,
                                     const char* selector,
                                     void* message)
{
    SPErr status = kSPNoError;

    SPMessageData *basicMessage = (SPMessageData *)message;

    sSPBasic = basicMessage->basic;

    if (sSPBasic->IsEqual(caller, kSPInterfaceCaller)) {
        if (sSPBasic->IsEqual(selector, kSPInterfaceAboutSelector)) {
            DoAbout(basicMessage->self, AboutID);
        }

        if (sSPBasic->IsEqual(selector, kSPInterfaceStartupSelector)) {
            return kSPNoError;
        }

        if (sSPBasic->IsEqual(selector, kSPInterfaceShutdownSelector)) {
            status = UninitializePlugin();
        }
    }

    if (sSPBasic->IsEqual(caller, kPSPhotoshopCaller)) {
        if (sSPBasic->IsEqual(selector, kPSDoIt)) {
            PSActionsPlugInMessage *tmpMsg = (PSActionsPlugInMessage *)message;
        }
    }

    return status;
}
~~~~~~
While things here should be fairly self-explanatory, I'll go over a couple of
slightly important bits that are useful to keep in mind as you continue
development:

~~~~~~cpp
SPBasicSuite *sSPBasic = NULL;
~~~~~~


This seems rather innocuous, but is actually required; it's used for the
new/delete operators that are used whenever you accquire or release what Adobe
refers to as **suites**. Suites are essentially libraries of functionality that
are specific to a product i.e. Photoshop would have its own suite, along with
Illustrator. As mentioned, you accquire and release suites whenever you use the
functionality from a specific suite.

In this case, we release the suite when we unload the plugin, in the
`UninitializePlugin` call.

The next few lines of code are also fairly straightforward:

~~~~~~cpp
    SPMessageData *basicMessage = (SPMessageData *)message;

    sSPBasic = basicMessage->basic;

    if (sSPBasic->IsEqual(caller, kSPInterfaceCaller)) {
        if (sSPBasic->IsEqual(selector, kSPInterfaceAboutSelector)) {
            DoAbout(basicMessage->self, AboutID);
        }

        if (sSPBasic->IsEqual(selector, kSPInterfaceStartupSelector)) {
            return kSPNoError;
        }

        if (sSPBasic->IsEqual(selector, kSPInterfaceShutdownSelector)) {
            status = UninitializePlugin();
        }
    }

    if (sSPBasic->IsEqual(caller, kPSPhotoshopCaller)) {
        if (sSPBasic->IsEqual(selector, kPSDoIt)) {
            PSActionsPlugInMessage *tmpMsg = (PSActionsPlugInMessage *)message;
        }
    }
~~~~~~

When Photoshop calls our `AutoPluginMain` entry point, you can see that it
passes in a `message` parameter. This message is basically used to tell the
plugin what context it's being called in, and thus allow the plugin to react
accordingly. So we see that we check against `kSPInterfaceAboutSelector`,
`kSPInterfaceStartupSelector`, `kSPInterfaceShutdownSelector`, and
`kPSPhotoshopCaller` in order to decide what to do (where, of course, that last
one means that the user just activated the plug-in from the Automation menu in
the Photoshop UI). Nothing should be too mystical or obtuse here.

You'll notice here that we actually haven't done any code that will do printing
of "Hello world" or anything of the sort yet. That's because Photoshop is not a
console application on Windows, and thus we won't actually see anything if we
just `printf` our way around. So for now, let's just write some simple code to
launch a message dialog with the necessary text:

~~~~~~cpp
#include <SPBasic.h>
#include <SPInterf.h>

#include <PIActionsPlugin.h>
#include <PIUtilities.h>

#include <Windows.h>
#include <string.h>
#include <assert.h>

#include <DialogUtilitiesWin.cpp>
#include <PIDLLInstance.cpp>
#include <PIUSuites.cpp>
#include <PIUtilities.cpp>
#include <PIUtilitiesWin.cpp>
#include <PIWinUI.cpp>


#define WIN32_MAX_CLASS_NAME_LENGTH 256

SPBasicSuite *sSPBasic = NULL;
HWND globalPSMainWindowHwnd = NULL;


BOOL CALLBACK getPSMainWindowCB(HWND hwnd, LPARAM lParam)
{
    char windowClassName[WIN32_MAX_CLASS_NAME_LENGTH];
    GetClassNameA(hwnd, (LPSTR)windowClassName, WIN32_MAX_CLASS_NAME_LENGTH);

    if (strncmp(windowClassName, "Photoshop", WIN32_MAX_CLASS_NAME_LENGTH) == 0) {
        globalPSMainWindowHwnd = hwnd;
    }

    return TRUE;
}


SPErr UninitializePlugin()
{
    PIUSuitesRelease();
    return status;
}


DLLExport SPAPI SPErr AutoPluginMain(const char* caller,
                                     const char* selector,
                                     void* message)
{
    SPErr status = kSPNoError;

    SPMessageData *basicMessage = (SPMessageData *)message;

    sSPBasic = basicMessage->basic;

    if (sSPBasic->IsEqual(caller, kSPInterfaceCaller)) {
        if (sSPBasic->IsEqual(selector, kSPInterfaceAboutSelector)) {
            DoAbout(basicMessage->self, AboutID);
        }

        if (sSPBasic->IsEqual(selector, kSPInterfaceStartupSelector)) {
            return kSPNoError;
        }

        if (sSPBasic->IsEqual(selector, kSPInterfaceShutdownSelector)) {
            status = UninitializePlugin();
        }
    }

    if (sSPBasic->IsEqual(caller, kPSPhotoshopCaller)) {
        if (sSPBasic->IsEqual(selector, kPSDoIt)) {
            PSActionsPlugInMessage *tmpMsg = (PSActionsPlugInMessage *)message;
            BOOL status = EnumWindows(getPSMainWindowCB, (LPARAM)NULL);
            assert(status != 0);
            MessageBoxA(globalPSMainWindowHwnd, "Hello World!", "Tutorial Dialog", MB_OK|MB_ICONINFORMATION);
        }
    }

    return status;
}
~~~~~~

So the code exploded a little bit, but none of this should be unfamilar to
anyone who's written Win32 code before; we basically enumerate the open windows
of the desktop to see which window matches the Photoshop one (since Photoshop
disallows itself from running multiple instances, this hack works fine**, and
launch a message dialog with our text.

Ok, so far the code is fairly straightforward. Now what combination of compiler
flags and post-build steps do we need to make this a DLL that Photoshop can load?

## Overview of the build process ##

Before we start writing the build script, there's a few wrenches in the works
that Adobe has thrown in when it comes to building our plug-in. Here's the
summary of what you'll need to do in order to get your plug-in to load in Photoshop,
illustrated in the diagram below:

********************************************************************
*  +---------------------+                                         *
*  |                     |   (C code that just tells Photoshop     *
*  |    PiPL source file |  how to load your plug-in and other     *
*  |                     |  metadata associated with it)           *
*  +----------+----------+                                         *
*             |                                                    *
*             |  preprocessor (MSVC)                               *
*             |                                                    *
*             |                                                    *
*  +----------v------------+                                       *
*  |                       |                                       *
*  |    .rr file           |                                       *
*  |                       |         (Your actual plug-in code)    *
*  +-----------+-----------+                                       *
*              |                     +----------------------+      *
*              | Cvntpipl.exe        |                      |      *
*              |                     |    .c/.cpp source(s) |      *
*              |                     |                      |      *
*  +-----------v------------+        +-----------+----------+      *
*  |                        |                    |                 *
*  | .rc Windows Resource   |                    |                 *
*  |        script          |                    |  MSVC compiles  *
*  +-----------+------------+                    |                 *
*              |                                 |                 *
*              | Resource Compiler               |                 *
*              |   (rc.exe)          +-----------v-----------+     *
*              |                     |                       |     *
*  +-----------v------------+        |       .obj files      |     *
*  |                        |        |                       |     *
*  |   .res resource file   |        +------------+----------+     *
*  |                        |                     |                *
*  +----------+-------------+                     |                *
*             |                                   |                *
*             |                                   |                *
*             +-----------------+-----------------+                *
*                               |                                  *
*                               |   MSVC linker                    *
*              +----------------v------------------+               *
*              |                                   |               *
*              |        DLL plug-in                |               *
*              | that actually gets loaded into PS |               *
*              +-----------------+-----------------+               *
*    +----------------------+    |                                 *
*    |                      |    |                                 *
*    |  .p12 certificate    +----+   ZXPSignCmd.exe                *
*    +----------------------+    |                                 *
*                                |                                 *
*               +----------------v-------------------+             *
*               |                                    |             *
*               |      .zxp archive                  |             *
*               | that actually gets distributed     |             *
*               +------------------------------------+             *
*                                                                  *
********************************************************************

It's rather involved, as you can see, which is unfortunate. You'll also notice
that I reference some executables which are probably unfamiliar, notably
`Cvntpipl.exe` and `ZXPSignCmd.exe`. The former is available in the Photoshop
SDK, while the latter is available in the CEP SDK. I won't go into a discussion
of _why_ things are this way; for now, we'll just accept it as a by-product of
Photoshop's legacy.

(Also because if I _did_ go into a discussion about it, I'd probably never
finish writing this document.)

There's also something here that might seem unfamilar, namely the PiPL
properties file and `.res` resource file that the **Resource Compiler** creates.
Shorthand for **Plug-in Property Lists**, the former is basically a C file that
contains various types of information about your plug-in (i.e. what type of
plug-in it is, who the author is, how Photoshop should load it), that eventually
gets transformed into a `.res` resource file and then built into the final DLL
through the (needlessly convoluted) steps listed above. Really, the entire
branch on the left is all about just adding plug-in metadata so that Photoshop
knows how to treat our plug-in. That's it.

!!! tip Crossing the platforms
    On OSX, you'll make use of [Rez](https://www.unix.com/man-page/osx/1/Rez/)
    to compile the PiPL file instead. I'll not be covering it in this tutorial,
    since the steps are essentially the same, just using different OS tools to
    get the job done.

## Writing the PiPL ##

So what exactly does a PiPL file look like, then? Luckily, the samples included
in the documentation provide most of the starting points we need. First, let's
define some globals in a file called `tutorial_automation_globals.h`:

~~~~~~cpp
#define TUTORIAL_AUTOMATION_PLUGINNAME "AutomationTutorial"
#define TUTORIAL_AUTOMATION_PLUGINDESC "An example automation plug-in for Adobe Photoshop."
#define TUTORIAL_AUTOMATION_UUID "267c8093-d35c-4fb7-b0ae-7b224c7fc1ce"
#define TUTORIAL_AUTOMATION_RESOURCE_ID 18601
#define TUTORIAL_AUTOMATION_SUITE_ID 'exam'
#define TUTORIAL_AUTOMATION_CLASS_ID TUTORIAL_AUTOMATION_SUITE_ID
#define TUTORIAL_AUTOMATION_EVENT_ID 'ExAm'
#define TUTORIAL_AUTOMATION_VENDORNAME "memyselfandi"
~~~~~~

You can generate the UUID using any tool of your choice. On Windows, you can
use ``uuidgen.exe``.

The PiPL resource file then follows, like so:

~~~~~~cpp
#include "PIDefines.h"
#include "tutorial_automation_globals.h"

#ifdef __PIMac__
    #include "PIGeneral.r"
    #include "PIUtilities.r"
#elif defined(__PIWin__)
    #define Rez
    #include "PIGeneral.h"
    #include "PIUtilities.r"
#endif

#include "PITerminology.h"
#include "PIActions.h"

resource 'PiPL' ( TUTORIAL_AUTOMATION_RESOURCE_ID, TUTORIAL_AUTOMATION_PLUGINNAME, purgeable)
    {
        {
        Kind { Actions },
        Name { TUTORIAL_AUTOMATION_PLUGINNAME },
        Category { "AdobeSDK" },
        Version { (latestActionsPlugInVersion << 16) | latestActionsPlugInSubVersion },

        Component { ComponentNumber, TUTORIAL_AUTOMATION_PLUGINNAME },

        #ifdef __PIMac__
            CodeMacIntel64 { "AutoPluginMain" },
        #else
            #if defined(_WIN64)
                CodeWin64X86 { "AutoPluginMain" },
            #else
                CodeWin32X86 { "AutoPluginMain" },
            #endif
        #endif

        EnableInfo { "true" },

        HasTerminology
            {
            TUTORIAL_AUTOMATION_CLASS_ID,
            TUTORIAL_AUTOMATION_EVENT_ID,
            TUTORIAL_AUTOMATION_RESOURCE_ID,
            TUTORIAL_AUTOMATION_UUID
            },

        Persistent{},

        // Only relevant if Persistent is set.
        Messages
        {
            startupRequired,
            doesNotPurgeCache,
            shutdownRequired,
            acceptProperty
        },
        }
    };

//-------------------------------------------------------------------------------
//  Dictionary (scripting) resource
//-------------------------------------------------------------------------------
resource 'aete' (TUTORIAL_AUTOMATION_RESOURCE_ID, TUTORIAL_AUTOMATION_PLUGINNAME " dictionary", purgeable)
    {
    1, 0, english, roman,                   /* aete version and language specifiers */
        {
        TUTORIAL_AUTOMATION_VENDORNAME,                             /* vendor suite name */
        TUTORIAL_AUTOMATION_PLUGINDESC,         /* optional description */
        TUTORIAL_AUTOMATION_SUITE_ID,   /* suite ID */
        1,                                  /* suite code, must be 1 */
        1,                                  /* suite level, must be 1 */
            {                               /* structure for automation */
            TUTORIAL_AUTOMATION_PLUGINNAME,         /* name */
            TUTORIAL_AUTOMATION_PLUGINDESC,         /* optional description */
            TUTORIAL_AUTOMATION_CLASS_ID,       /* class ID, must be unique or Suite ID */
            TUTORIAL_AUTOMATION_EVENT_ID,       /* event ID, must be unique */

            NO_REPLY,                       /* never a reply */
            IMAGE_DIRECT_PARAMETER,             /* direct parameter, used by Photoshop */
                {                           // filter or selection class here:
                }
            },
            {},     /* non-filter/automation plug-in class here */
            {}, /* comparison ops (not supported) */
            { // Enumerations go here:
            }   /* end of any enumerations */
        }
    };
~~~~~~
The eagle-eyed (or incredibly bored) viewer might have noticed the addition of
the lines:

~~~~~~cpp
        EnableInfo { "true" },

        ...

        Persistent{},

        // Only relevant if Persistent is set.
        Messages
        {
            startupRequired,
            doesNotPurgeCache,
            shutdownRequired,
            acceptProperty
        },
~~~~~~

The former basically disables the plugin in the menu unless an actual Photoshop
document is currently open (which is nice sometimes, as you don't want to trick
users into thinking that they can execute when they actually can't). The latter
basically allows us to keep the plug-in loaded into memory on startup (which is
what I usually do, since I initialize a bunch of things the moment my plugin
loads into Photoshop.) You can omit this if you'd like.

## Package signing (optional) ##

There's another optional step after building the plug-in that also involves
something called a `.p12` certificate, which is used by `ZXPSignCmd.exe`. What
exactly is that? If we take a look at
the [documentation](https://wwwimages2.adobe.com/content/dam/acom/en/devnet/creativesuite/pdfs/SigningTechNote_CC.pdf),
we see that it's basically Adobe's way of allowing developers to certify that
their code has not been altered before being deployed to end-users (presumably
because most extensions are written in JSX/JavaScript and people are scared
about that sort of thing? Who knows.) Either way, this means that you'll need to
generate one of these certifcates as well if you want to be able to deploy your
extension to other end-users through the Extension Manager or Adobe marketplace.

If you actually just want to make a DLL and deploy it to end-users manually (by
copying and pasting the plug-in to the appropriate location), then you can skip
this step entirely.

### Generating a certificate ###

To generate the certificate, we'll make a self-signed one for now. You can, of
course, pay money to a Certificate Authority (CA) and get one there, but for
personal usage, a self-signed one will suffice. Thankfully, we can do this as
well using the `ZXPSignCmd.exe` tool. From the [documentation](https://github.com/Adobe-CEP/Getting-Started-guides/tree/master/Package%20Distribute%20Install#acquiring-a-signed-certificate):

~~~~~~batch
ZXPSignCmd -selfSignedCert <countryCode> <stateOrProvince> <organization> <commonName> <password> <outputPath.p12> [options]
~~~~~~

You will then get a `.p12` file which you can for creating your packaged native
extension later on.


## Writing the build script ##

Create a new file called `build.bat`, and let's get started writing up the
previous diagram into code:

~~~~~~batch
@echo off
setlocal

set PhotoshopSDKRoot=C:\Users\sonict\src\thirdparty\adobe\cc2019\photoshop\pluginsdk
set PhotoshopPluginsDeployPath=C:\Users\sonictk\psplugins

set ZXPSignCmdExe=C:\Users\sonictk\Git\adobe\CEP-Resources\ZXPSignCMD\4.0.7\win64\ZXPSignCmd.exe
set ZXPCert=C:\Users\sonictk\cert.p12
set ZXPCertPassword=password123

call "%vs2017installdir%\VC\Auxiliary\Build\vcvarsall.bat" x64

set BuildDir=%~dp0msbuild
if not exist %BuildDir% mkdir %BuildDir%
pushd %BuildDir%
~~~~~~

Yes, I'm putting the signing password into the build script since the
certificate is self-signed and of no practical use in terms of being a security
device. For now, let's just move on and set up the compiler flags we're going to use.

~~~~~~batch
set ProjectName=tutorial_automation

set EntryPoint=%~dp0src\%ProjectName%_main.cpp
set ResourcePiPL=%~dp0src\%ProjectName%_pipl.r
set ResourceRC=%BuildDir%\%ProjectName%_pipl.rc
set ResourceRES=%BuildDir%\%ProjectName%_pipl.res

set ThirdPartyDirPath=%~dp0..\thirdparty

set OutBin=%BuildDir%\%ProjectName%.8li

set CommonLinkerFlags=/dll /incremental:no /machine:x64 /nologo /defaultlib:Kernel32.lib /defaultlib:User32.lib /defaultlib:Shell32.lib /nodefaultlib:LIBCMTD.lib /nodefaultlib:LIBCMT.lib "%ResourceRES%"
set DebugLinkerFlags=%CommonLinkerFlags% /opt:noref /debug /pdb:"%BuildDir%\%ProjectName%.pdb"
set ReleaseLinkerFlags=%CommonLinkerFlags% /opt:ref
set RelWithDebInfoLinkerFlags=%CommonLinkerFlags% /opt:ref /debug /pdb:"%BuildDir%\%ProjectName%.pdb"

set PSPreprocessorDefines=/DISOLATION_AWARE_ENABLED=1 /DWIN32=1 /D_CRT_SECURE_NO_DEPRECATE /D_SCL_SECURE_NO_DEPRECATE /D_WINDOWS /D_USRDLL /D_WINDLL /D_MBCS
set PSCompilerFlags=/EHsc
set CommonIncludePaths=/I "%ThirdPartyDirPath%" /I "%ThirdPartyDirPath%\psapi\common\includes" /I "%ThirdPartyDirPath%\psapi\common\resources" /I "%ThirdPartyDirPath%\psapi\common\sources" /I "%ThirdPartyDirPath%\psapi\photoshop" /I "%ThirdPartyDirPath%\psapi\pica_sp" /I "%ThirdPartyDirPath%\psapi\resources" /I "%ThirdPartyDirPath%\psapi\ai" /I "%BuildDir%"
set CommonCompilerFlags=/nologo /W3 /WX %CommonIncludePaths% /Zc:__cplusplus /arch:AVX2 %PSCompilerFlags% %PSPreprocessorDefines%
set CompilerFlagsDebug=%CommonCompilerFlags% /Od /Zi /D_DEBUG /MDd
set CompilerFlagsRelease=%CommonCompilerFlags% /Ox /DNDEBUG /MD
set CompilerFlagsRelWithDebInfo=%CommonCompilerFlags% /Ox /Zi /DNDEBUG /MD
~~~~~~

You can see that we have a bunch of extra preprocessor defines in there, some of
which might make no sense (or be even spurious). Leave it all be for now, and
let's set up the compilation commands themselves.

~~~~~~batch
echo.
echo Compiling resources (command follows below)...
set ResourceRR=%BuildDir%\%ProjectName%_pipl.rr

echo %BuildRRCommand%
%BuildRRCommand% > "%ResourceRR%"
if %errorlevel% neq 0 goto error

echo.
echo Converting PiPL to  Windows resource file format...
%CnvtPiPLExePath% "%ResourceRR%" "%ResourceRC%"
if %errorlevel% neq 0 goto error

echo.
echo Compiling Windows Resources...
rc /v /fo "%ResourceRES%" "%ResourceRC%"
if %errorlevel% neq 0 goto error

echo.
echo Compiling source files for automation filter (command follows below)...
echo %BuildCommand%
echo.
echo Output from compilation:
%BuildCommand%
if %errorlevel% neq 0 goto error
~~~~~~

For Photoshop, there's one thing that helps us when it comes to deploying our
extensions: the normal path where you're supposed to deploy extensions to is
the `Plug-ins` folder located in your Photoshop installation directory
(i.e. `%programfiles%\Adobe\Adobe Photoshop 2020\Plug-ins`). However, this
directory is searched recursively for suitable plug-in files, along with
following shortcuts as well. Thus, what I usually do is make a shortcut link in
the folder itself to a deploy location (which is why we define
`PhotoshopPluginsDeployPath` above), and just copy the plug-ins there, like so:

~~~~~~batch
echo.
echo Deploying built binaries and symbols...
copy /Y "%OutBin%"  "%PhotoshopPluginsDeployPath%"
if %errorlevel% neq 0 goto error

copy /Y "%BuildDir%\%ProjectName%.pdb" "%PhotoshopPluginsDeployPath%"
if %errorlevel% neq 0 goto error
~~~~~~

We copy the `.pdb` file as well, since it'll help the MSVC debugger when we want
to end up debugging the plug-in later on if there's a problem.

Finally, we build and sign the `.zxp` extension package for deployment to
end-users, and we're done with the build script!

~~~~~~batch
set OutZXP=%BuildDir%\%ProjectName%.zxp
set BuildZXPCommand=%ZXPSignCmdExe% -sign "%~dp0msbuild" "%OutZXP%" "%ZXPCert%" %ZXPCertPassword%

echo.
echo Building ZXP Photoshop extension package (command follows below)...
echo %BuildZXPCommand%

%BuildZXPCommand%

if %errorlevel% neq 0 goto error

if %errorlevel% == 0 goto success


:error
echo.
echo ***************************************
echo *      !!! An error occurred!!!       *
echo ***************************************
goto end


:success
echo.
echo ***************************************
echo *    Build completed successfully.    *
echo ***************************************
goto end


:end
echo.
echo Build script finished execution at %time%.
popd

endlocal

exit /b %errorlevel%
~~~~~~

!!! tip
    The full version of this build script is available in the accompanying code
    repository for this tutorial.

Run ``build.bat`` and wait for the process to spit out the `.8li` DLL.

After you've made sure that you've deployed the plugin in a suitable location
that Photoshop can find, go ahead and open Photoshop, then launch your plug-in
from the Automation menu. You should see the following message box appear:

***************************************
*                                     *
*   +--------------------------+---+  *
*   |  Tutorial Dialog         | X |  *
*   +--------------------------+---+  *
*   |                              |  *
*   |   -----                      |  *
*   |  (  i  )  Hello World!       |  *
*   |   -----                      |  *
*   +------------------------------+  *
*   |                 +----------+ |  *
*   |                 |    OK    | |  *
*   |                 +----------+ |  *
*   +------------------------------+  *
*                                     *
***************************************

Congratulations, you've just made your first native plug-in in Photoshop!

## Debugging your plug-in ##

Let's make sure we're able to debug our plug-in first before we get carried
away. If you've been following along so far, run `build.bat debug` in order to
generate a version of the `.8li` with optimizations disabled and an accompanying
`.pdb` file generated alongside it as well.

After that, launch Photoshop and Visual Studio. You should be able to attach to
the Photoshop process, set a breakpoint, then run your Automation action; the
breakpoint in Visual Studio should get triggered and allow you to step through
your plug-in.

!!! warning Threading in Photoshop plug-ins
    Basically, **no**. The Photoshop API is **not thread-safe**, so threading in
    plug-ins is generally not advisable.

Now that we have a basic build-deploy-debug workflow going, we can finally start
to do something mildly useful with it.

# Recipe: Reading layer data through C++ #



# Recipe: Running a Filter from an Automation plug-in #

# Recipe: Integrating ImGui with Photoshop #

# Recipe: Communicating between CEP panels and C++ plug-ins #

# Credits #

* Tom Ruark, for assisting with some of my queries, cryptic though his replies were.


<style class="fallback">body{visibility:hidden}</style><script>markdeepOptions={tocStyle:'medium'};</script>
<!-- Markdeep: --><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>
